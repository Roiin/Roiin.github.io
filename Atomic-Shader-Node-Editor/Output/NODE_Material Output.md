**Editor:** Shader Editor  
**Engine(s) Supported:** [Cycles & Eevee]  
**Node Group:** Output

**Core Function:** Serves as the final endpoint for a material, connecting the calculated surface, volume, and displacement information from the node tree to the object itself.

**Key Properties & Settings:**

- **Surface (Input):** The primary input where the final BSDF shader (e.g., a Principled BSDF) is connected. This defines the visible appearance, color, and texture of the object's surface.
    
- **Volume (Input):** This input is used for volumetric materials. A volume shader (e.g., Principled Volume) connected here will define the properties of the object's interior, such as for creating smoke, fog, or cloudy **ice**.
    
- **Displacement (Input):** Accepts height or vector data (from a Bump or Displacement node) to alter the surface normals for fake bumps or to physically move the geometry at render time for true displacement.
    
- **Target:** A property that allows you to specify if the output is for All render engines, or just for Cycles or Eevee. This enables you to have two different Material Output nodes in one tree, allowing for a complex, ray-traced setup for Cycles and a separate, optimized setup for Eevee.
    

**Practical Application:**  
The Material Output node is the final bridge between your abstract node network and the rendered object. Imagine you are creating a complex material for a chunk of rough **ice**. This material needs three distinct components: a shiny, transparent surface; a cloudy, light-scattering interior; and a bumpy, imperfect surface structure.

The problem is that these three components are generated by different shaders and textures. How do you tell Blender to combine them correctly? The Material Output node is the solution, acting as the final assembly point.

1. For the **surface**, you create a Principled BSDF with high transmission and low roughness. You plug this into the Surface input. This tells Blender: "This is what the outside of the object looks like."
    
2. For the **volume**, you create a Principled Volume shader with a slight density to represent the cloudy interior. You plug this into the Volume input. This tells Blender: "This is how light should behave inside the object."
    
3. For the **displacement**, you use a Noise Texture connected to a Bump node to simulate a rough, uneven surface. You plug this into the Displacement input. This tells Blender: "Alter the surface geometry to look like this."
    

The Material Output node takes these three separate instructions—Surface, Volume, and Displacement—and applies them all together correctly onto the final object at render time. Without this node, your shader setup is just a collection of disconnected calculations with no final destination.